var searchIndex = {};
searchIndex["pest"] = {"doc":"# pest. Elegant, efficient grammars","items":[[3,"StringInput","pest","A `struct` useful for matching in-memory `String`s.",null,null],[3,"Token","","A `struct` representing tokens generated by a parser.",null,null],[12,"rule","","matched [`Rule`](macro.impl_rdp!#rule)",0,null],[12,"start","","starting position in `Input`",0,null],[12,"end","","ending position in `Input`",0,null],[11,"eq","","",0,{"inputs":[{"name":"token"},{"name":"token"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"token"},{"name":"token"}],"output":{"name":"bool"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"token"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"token"}],"output":{"name":"token"}}],[11,"new","","Creates a new `StringInput` from a `&amp;str`.",1,{"inputs":[{"name":"str"}],"output":{"name":"stringinput"}}],[11,"len","","",1,{"inputs":[{"name":"stringinput"}],"output":{"name":"usize"}}],[11,"is_empty","","",1,{"inputs":[{"name":"stringinput"}],"output":{"name":"bool"}}],[11,"pos","","",1,{"inputs":[{"name":"stringinput"}],"output":{"name":"usize"}}],[11,"set_pos","","",1,{"inputs":[{"name":"stringinput"},{"name":"usize"}],"output":null}],[11,"slice","","",1,{"inputs":[{"name":"stringinput"},{"name":"usize"},{"name":"usize"}],"output":{"name":"str"}}],[11,"line_col","","",1,null],[11,"match_string","","",1,{"inputs":[{"name":"stringinput"},{"name":"str"}],"output":{"name":"bool"}}],[11,"match_range","","",1,{"inputs":[{"name":"stringinput"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[0,"prelude","","A `mod` that contains `pest::Input`, `pest::Parser`, `pest::StringInput`, and `pest::Token`.",null,null],[3,"StringInput","pest::prelude","A `struct` useful for matching in-memory `String`s.",null,null],[3,"Token","","A `struct` representing tokens generated by a parser.",null,null],[12,"rule","","matched [`Rule`](macro.impl_rdp!#rule)",0,null],[12,"start","","starting position in `Input`",0,null],[12,"end","","ending position in `Input`",0,null],[8,"Input","","A `trait` that defines an input for a `Parser`.",null,null],[10,"len","","Returns length of an `Input`.",2,{"inputs":[{"name":"input"}],"output":{"name":"usize"}}],[10,"is_empty","","Returns whether an `Input` is empty.",2,{"inputs":[{"name":"input"}],"output":{"name":"bool"}}],[10,"pos","","Returns current position of an `Input`.",2,{"inputs":[{"name":"input"}],"output":{"name":"usize"}}],[10,"set_pos","","Set current position of an `Input`.",2,{"inputs":[{"name":"input"},{"name":"usize"}],"output":null}],[10,"slice","","Slices an `Input`.",2,{"inputs":[{"name":"input"},{"name":"usize"},{"name":"usize"}],"output":{"name":"str"}}],[10,"line_col","","Returns the line and column of a position for an `Input`.",2,null],[10,"match_string","","Matches `string` to an `Input`, returns whether it matched, and advances the position with\n`string.len()` in case it did.",2,{"inputs":[{"name":"input"},{"name":"str"}],"output":{"name":"bool"}}],[10,"match_range","","Matches if an `Input`&#39;s current `char` is between `left` and `right`, and advances the\nposition with one `char` in case it did.",2,{"inputs":[{"name":"input"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[8,"Parser","","A `trait` that defines a parser.",null,null],[16,"Rule","","",3,null],[16,"Token","","",3,null],[10,"match_string","","Matches `string`, returns whether it matched, and advances a parser with `string.len()` in\ncase it did.",3,{"inputs":[{"name":"parser"},{"name":"str"}],"output":{"name":"bool"}}],[10,"match_range","","Matches `char` between `left` and `right`, and advances a parser with one `char` in case\nit did.",3,{"inputs":[{"name":"parser"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[10,"try","","Tries to match `rule`, returns whether it matched, and advances a parser with in case it\ndid. If `revert` is `true`, the parser will not advance.",3,{"inputs":[{"name":"parser"},{"name":"bool"},{"name":"f"}],"output":{"name":"bool"}}],[10,"prec_climb","","Uses the precendence climbing algorithm to match rules. `pos` is the current position\nof the queue. `left` is the left-most starting position of the current rule. `min_prec` is\nthe currently processed precedence. `last_op` is the last greedily parsed infix operator.\n`primary` is a closure defined in `grammar!` that parses a primary expression. `climb` is a\nclosure defined in `grammar!` that returns the first `Rule` that was parsed (provided it\nwas not silented) along with its precedence and right-associativity, or `None` if no\noperator passes. This operator triplet is also returned by the function when it greedily\nparses an operator useful for a higher precedence.",3,null],[10,"pos","","Returns the current position of a `Parser`.",3,{"inputs":[{"name":"parser"}],"output":{"name":"usize"}}],[10,"set_pos","","Sets the position of a `Parser`.",3,{"inputs":[{"name":"parser"},{"name":"usize"}],"output":null}],[10,"end","","Returns whether a `Parser` has reached its end.",3,{"inputs":[{"name":"parser"}],"output":{"name":"bool"}}],[10,"eoi_matched","","Returns whether a `Parser` has matched end-of-input.",3,{"inputs":[{"name":"parser"}],"output":{"name":"bool"}}],[10,"reset","","Reset a `Parser`.",3,{"inputs":[{"name":"parser"}],"output":null}],[10,"slice_input","","Slices a `Parser`&#39;s `Input`.",3,{"inputs":[{"name":"parser"},{"name":"usize"},{"name":"usize"}],"output":{"name":"str"}}],[10,"queue","","Returns the queue of all matched `Token`s.",3,{"inputs":[{"name":"parser"}],"output":{"name":"vec"}}],[10,"queue_mut","","Returns the mutable queue of all matched `Token`s.",3,{"inputs":[{"name":"parser"}],"output":{"name":"vec"}}],[10,"queue_index","","Returns the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"parser"}],"output":{"name":"usize"}}],[10,"inc_queue_index","","Increments the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"parser"}],"output":null}],[10,"set_queue_index","","Set the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"parser"},{"name":"usize"}],"output":null}],[10,"skip_ws","","Skips white-space.",3,{"inputs":[{"name":"parser"}],"output":null}],[10,"skip_com","","Skips comments.",3,{"inputs":[{"name":"parser"}],"output":null}],[10,"is_atomic","","Returns whether a `Parser` is currently inside an atomic rule.",3,{"inputs":[{"name":"parser"}],"output":{"name":"bool"}}],[10,"set_atomic","","Sets a `Parser` to atomic rule mode, barring comment &amp; white-space skipping.",3,{"inputs":[{"name":"parser"},{"name":"bool"}],"output":null}],[10,"track","","Keeps track of rule failures. It gets called when a `Rule` fails at `pos`.",3,{"inputs":[{"name":"parser"},{"name":"rule"},{"name":"usize"}],"output":null}],[10,"tracked_len","","Returns the length of the tracked `Rule`s.",3,{"inputs":[{"name":"parser"}],"output":{"name":"usize"}}],[10,"expected","","Retuns a `Vec` of all expected `Rule`s at the deepest position where the parsing last\nstopped. It only returns leafs from the rule tree. Used for error reporting.",3,null],[8,"Input","pest","A `trait` that defines an input for a `Parser`.",null,null],[10,"len","","Returns length of an `Input`.",2,{"inputs":[{"name":"input"}],"output":{"name":"usize"}}],[10,"is_empty","","Returns whether an `Input` is empty.",2,{"inputs":[{"name":"input"}],"output":{"name":"bool"}}],[10,"pos","","Returns current position of an `Input`.",2,{"inputs":[{"name":"input"}],"output":{"name":"usize"}}],[10,"set_pos","","Set current position of an `Input`.",2,{"inputs":[{"name":"input"},{"name":"usize"}],"output":null}],[10,"slice","","Slices an `Input`.",2,{"inputs":[{"name":"input"},{"name":"usize"},{"name":"usize"}],"output":{"name":"str"}}],[10,"line_col","","Returns the line and column of a position for an `Input`.",2,null],[10,"match_string","","Matches `string` to an `Input`, returns whether it matched, and advances the position with\n`string.len()` in case it did.",2,{"inputs":[{"name":"input"},{"name":"str"}],"output":{"name":"bool"}}],[10,"match_range","","Matches if an `Input`&#39;s current `char` is between `left` and `right`, and advances the\nposition with one `char` in case it did.",2,{"inputs":[{"name":"input"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[8,"Parser","","A `trait` that defines a parser.",null,null],[16,"Rule","","",3,null],[16,"Token","","",3,null],[10,"match_string","","Matches `string`, returns whether it matched, and advances a parser with `string.len()` in\ncase it did.",3,{"inputs":[{"name":"parser"},{"name":"str"}],"output":{"name":"bool"}}],[10,"match_range","","Matches `char` between `left` and `right`, and advances a parser with one `char` in case\nit did.",3,{"inputs":[{"name":"parser"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[10,"try","","Tries to match `rule`, returns whether it matched, and advances a parser with in case it\ndid. If `revert` is `true`, the parser will not advance.",3,{"inputs":[{"name":"parser"},{"name":"bool"},{"name":"f"}],"output":{"name":"bool"}}],[10,"prec_climb","","Uses the precendence climbing algorithm to match rules. `pos` is the current position\nof the queue. `left` is the left-most starting position of the current rule. `min_prec` is\nthe currently processed precedence. `last_op` is the last greedily parsed infix operator.\n`primary` is a closure defined in `grammar!` that parses a primary expression. `climb` is a\nclosure defined in `grammar!` that returns the first `Rule` that was parsed (provided it\nwas not silented) along with its precedence and right-associativity, or `None` if no\noperator passes. This operator triplet is also returned by the function when it greedily\nparses an operator useful for a higher precedence.",3,null],[10,"pos","","Returns the current position of a `Parser`.",3,{"inputs":[{"name":"parser"}],"output":{"name":"usize"}}],[10,"set_pos","","Sets the position of a `Parser`.",3,{"inputs":[{"name":"parser"},{"name":"usize"}],"output":null}],[10,"end","","Returns whether a `Parser` has reached its end.",3,{"inputs":[{"name":"parser"}],"output":{"name":"bool"}}],[10,"eoi_matched","","Returns whether a `Parser` has matched end-of-input.",3,{"inputs":[{"name":"parser"}],"output":{"name":"bool"}}],[10,"reset","","Reset a `Parser`.",3,{"inputs":[{"name":"parser"}],"output":null}],[10,"slice_input","","Slices a `Parser`&#39;s `Input`.",3,{"inputs":[{"name":"parser"},{"name":"usize"},{"name":"usize"}],"output":{"name":"str"}}],[10,"queue","","Returns the queue of all matched `Token`s.",3,{"inputs":[{"name":"parser"}],"output":{"name":"vec"}}],[10,"queue_mut","","Returns the mutable queue of all matched `Token`s.",3,{"inputs":[{"name":"parser"}],"output":{"name":"vec"}}],[10,"queue_index","","Returns the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"parser"}],"output":{"name":"usize"}}],[10,"inc_queue_index","","Increments the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"parser"}],"output":null}],[10,"set_queue_index","","Set the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"parser"},{"name":"usize"}],"output":null}],[10,"skip_ws","","Skips white-space.",3,{"inputs":[{"name":"parser"}],"output":null}],[10,"skip_com","","Skips comments.",3,{"inputs":[{"name":"parser"}],"output":null}],[10,"is_atomic","","Returns whether a `Parser` is currently inside an atomic rule.",3,{"inputs":[{"name":"parser"}],"output":{"name":"bool"}}],[10,"set_atomic","","Sets a `Parser` to atomic rule mode, barring comment &amp; white-space skipping.",3,{"inputs":[{"name":"parser"},{"name":"bool"}],"output":null}],[10,"track","","Keeps track of rule failures. It gets called when a `Rule` fails at `pos`.",3,{"inputs":[{"name":"parser"},{"name":"rule"},{"name":"usize"}],"output":null}],[10,"tracked_len","","Returns the length of the tracked `Rule`s.",3,{"inputs":[{"name":"parser"}],"output":{"name":"usize"}}],[10,"expected","","Retuns a `Vec` of all expected `Rule`s at the deepest position where the parsing last\nstopped. It only returns leafs from the rule tree. Used for error reporting.",3,null],[14,"grammar!","","A `macro` that defines each rule as a method on a `Parser` which parses from the current\nposition. Rules are always defined between braces, with an optional symbol marking the type of\nrule defined.",null,null],[14,"process!","","A `macro` for pattern-matching queued `Token`s generated by a `Parser`. It generates a method\n`process` on `&amp;self` that processes the whole queue of `Token`s, reducing it to one single\nresult.",null,null],[14,"impl_rdp!","","A `macro` useful for implementing the `Parser` `trait` as a recursive descent parser. It only\naccepts `grammar!` and `process!` calls that get implemented on `self`.",null,null]],"paths":[[3,"Token"],[3,"StringInput"],[8,"Input"],[8,"Parser"]]};
initSearch(searchIndex);
